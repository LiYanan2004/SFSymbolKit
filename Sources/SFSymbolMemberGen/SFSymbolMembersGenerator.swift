//
//  SFSymbolSourceFileGenerator.swift
//  SFSymbolKit
//
//  Created by LiYanan2004 on 2025/11/9.
//

import Foundation
import SwiftSyntax
import SwiftSyntaxBuilder

package struct SFSymbolMembersGenerator {
    package let directoryURL: URL
    
    package init(directoryURL: URL) {
        self.directoryURL = directoryURL
    }
    
    package func generate() throws {
        var availabilityCategorizedSymbols = [String : [SFSymbolDescriptor]]()
        SFSymbols_Private.allSymbols.forEach {
            availabilityCategorizedSymbols[$0.availability, default: []].append($0)
        }
        
        try FileManager.default.createDirectoryIfNecessary(
            for: directoryURL
        )
        
        for (availability, symbols) in availabilityCategorizedSymbols {
            let filename = "SFSymbol+Symbols.\(availability).swift"
            let fileURL = directoryURL.appendingPathComponent(filename)
            
            let fileSyntax = try sourceFile(filename: filename, members: symbols)
            try fileSyntax.description
                .write(to: fileURL, atomically: true, encoding: .utf8)
        }
    }
    
    private func sourceFile(
        filename: String,
        members: [SFSymbolDescriptor]
    ) throws -> SourceFileSyntax {
        let header = """
        //
        //  \(filename)
        //
        //  Automatically generated by sf-symbol-member-gen
        //  Do not edit directly!
        //  swift-format-ignore-file
        """
        
        return try SourceFileSyntax {
            try ExtensionDeclSyntax("extension SFSymbol") {
                try members.map { symbol in
                    try DeclSyntax(symbol.declarationSyntax)
                }
            }
        }
        .with(\.leadingTrivia, Trivia(stringLiteral: header) + .newlines(2))
    }
}

private extension Array {
    func chunked(into size: Int) -> [[Element]] {
        guard size > 0 else { return [self] }
        var result: [[Element]] = []
        result.reserveCapacity((count + size - 1) / size)
        var startIndex = 0
        while startIndex < count {
            let endIndex = Swift.min(startIndex + size, count)
            result.append(Array(self[startIndex..<endIndex]))
            startIndex = endIndex
        }
        return result
    }
}
